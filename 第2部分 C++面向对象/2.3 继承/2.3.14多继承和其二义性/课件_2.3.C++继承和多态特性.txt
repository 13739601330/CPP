***********    《朱有鹏老师热门编程语言全解》   ***********
***********    《1.跟朱老师从C高级到征服C++》   ***********
***********    朱老师C++第2部分-C++和面向对象 	***********
***********         2.3.C++继承和多态特性       ***********

--------------------------------------------------------
本课程由朱有鹏物联网大讲堂录制并拥有完整版权，翻录必究
--------------------------------------------------------
第一部分、章节目录
2.3.1.什么是面向对象的继承特性1
2.3.2.什么是面向对象的继承特性2
2.3.3.C++继承中的权限管控1
2.3.4.C++继承中的权限管控2
2.3.5.C++继承中的权限管控3
2.3.6.继承体系下子类和父类的关系1
2.3.7.继承体系下子类和父类的关系2
2.3.8.派生类和基类的构造析构关系1
2.3.9.派生类和基类的构造析构关系2
2.3.10.派生类和基类的同名成员问题
2.3.11.子类和父类的类型兼容规则
2.3.12.继承的优势与不良继承
2.3.13.组合介绍以及与继承对比
2.3.14.多继承及其二义性问题1
2.3.15.多继承及其二义性问题2
2.3.16.虚继承解决菱形继承的二义性问题
2.3.17.多态和虚函数1
2.3.18.多态和虚函数2
2.3.19.纯虚函数与抽象类1
2.3.20.纯虚函数与抽象类2
2.3.21.虚析构函数
2.3.22.using重新定义继承时访问权限



第二部分、章节介绍
2.3.1.什么是面向对象的继承特性1
	本节讲解面向对象的继承特性，解释继承的概念和效果。
2.3.2.什么是面向对象的继承特性2
	本节接上节继续讲解继承的概念和特性。
2.3.3.C++继承中的权限管控1
	本节讲解C++继承中的权限管控，public继承中父类的三种成员在子类中会如何。
2.3.4.C++继承中的权限管控2
	本节重点讲解父类private成员在子类中为什么存在但却无法被直接访问，以及如何间接访问。
2.3.5.C++继承中的权限管控3
	本节继续讲解父类中三种成员在三种继承方式下在子类中会如何确定访问权限。
2.3.6.继承体系下子类和父类的关系1
	本节讲解继承体系中站在子类角度如何看待父类，明确子类和父类其实是2个独立的类。
2.3.7.继承体系下子类和父类的关系2
	本节讲解在继承体系中为什么子类中还包含父类private成员但又无法直接访问。
2.3.8.派生类和基类的构造析构关系1
	本节讲解派生类的构造函数和基类的构造函数之间的隐含调用关系。
2.3.9.派生类和基类的构造析构关系2
	本节讲解派生类如何显式调用基类的各个重载的构造函数，以及派生类如何调用基类的析构函数。
2.3.10.派生类和基类的同名成员问题
	本节讲解派生类的隐藏规则，即派生类中如何处理和基类的同名成员问题。
2.3.11.子类和父类的类型兼容规则
	本节讲解子类和父类的类型兼容规则，这是通过父类指针或引用访问子类对象时的关键语法。
2.3.12.继承的优势与不良继承
	本节首先分析继承设计的优势，然后引入不良继承的概念，并分析其解决办法。
2.3.13.组合介绍以及与继承对比
	本节首先介绍组合的概念，然后对比继承和组合这2种面相对象中常用的代码复用技术的各自优劣。
2.3.14.多继承及其二义性问题1
	本节讲解多继承情况下的二义性问题，主要是多继承时多个父类中凑巧有同名方法时的二义性问题。
2.3.15.多继承及其二义性问题2
	本节接着讲解多继承情况下的二义性问题，主要是菱形继承问题，并且分析了几种可能的解决方案，但是都不完美。
2.3.16.虚继承解决菱形继承的二义性问题
	本节讲解如何通过虚继承技术解决菱形继承的二义性问题。
2.3.17.多态和虚函数1
	本节演示了通过父类指针调用子类对象时的问题并引入了多态和虚函数的概念。
2.3.18.多态和虚函数2
	本节重点讲了override覆盖，并且再次详细分析了它与重载overload和隐藏redifning的不同。
2.3.19.纯虚函数与抽象类1
	本节讲解纯虚函数的概念和用法，写代码验证了纯虚函数的特性。
2.3.20.纯虚函数与抽象类2
	本节重点讲解了纯虚函数、抽象类、抽象基类、接口等面向对象的重要概念和理念。
2.3.21.虚析构函数
	本节讲解了虚析构函数的用法和原理，重点是搞清楚什么情况下必须使用虚析构函数。
2.3.22.using重新定义继承时访问权限
	本节首先讲了using关键字在非公有继承中找回public权限的用法，然后对本部分课程进行了总结。
	


第三部分、随堂记录
2.3.1_2.什么是面向对象的继承特性1_2
2.3.1.1、类的继承案例
(1)基类为：person，派生类为man，所有权限均为public
(2)演示1：派生类“继承”了基类的成员变量
(3)演示2：派生类“继承”了基类的成员方法
(4)C++类的继承语法如下：
	class 派生类名:访问控制 基类名1,访问控制 基类名2,访问控制 基类名n
	{
		// 成员变量和成员方法列表（除了构造和析构之外的成员方法）
	};
2.3.1.2、什么是继承
(1)继承是C++源生支持的一种语法特性，是C++面向对象的一种表现
(2)继承特性可以让派生类“瞬间”拥有基类的所有（当然还得考虑权限）属性和方法
(3)继承特性本质上是为了代码复用
(4)类在C++编译器的内部可以理解为结构体，派生类是由基类成员叠加派生类新成员得到的
2.3.1.3、继承特性是天然的
(1)天然的意思就是：符合现实世界的本质规律，而不是纯粹人为施加的。
(2)继承inheritance和组合composition是软件重用的2种有效方式
(3)派生类,范围小,具体。 基类,范围大,抽象
(4)派生类又叫子类，基类又叫父类。两种叫法都有人常用，我们后面会混用，锻炼大家瞬间了然的能力

2.3.3_4_5.C++继承中的权限管控1_2_3
2.3.3.1、C++类中的访问权限管控回顾
(1)public			类内部可以访问，类的外部可以访问
(2)private			类内部可以访问，类的外部不能访问
(3)protected		类内部可以访问，类的外部不能访问
2.3.3.2、继承时的三种权限设置对派生类的影响
(1)public继承（公有继承）：父类成员在子类中保持原有访问级别
(2)private继承（私有继承）：父类成员在子类中变为private成员
(3)protected继承（保护继承）：父类中public成员会变成protected,父类中protected成员仍然为protected,父类中private成员仍然为private
(4)如果继承时不写则默认情况下派生类为class时是private继承，而派生类为struct时是public继承
2.3.3.3、设计类时如何规定成员的访问权限
(1)需要被外界访问的成员直接设置为public
(2)只能在当前类中访问的成员设置为private
(3)只能在当前类和子类中访问的成员设置为protected。
总结：
1、父类的public成员，经过public继承后，在子类中是public的。
2、父类的private成员，经过public继承后，在子类中是比private还可怜的。意思1是这个成员在子类中是存在的，意思是它不能被直接访问，在呢么访问？只能通过子类从父类继承而来的父类里实现了的成员函数来间接访问。
3、父类的protected成员，经过public继承后，在子类中是protected的。意思就是该成员在子类中是子类内部成员可以访问，子类对象外部不可以访问，子类再次去继承产生孙类中他还是protected的。
4、public继承，对于父类中public和protected成员的权限在子类中，其实是没有增强也没有削弱的；但是对于父类中private成员，其实在子类中是有削弱的（比private还可怜）
5、如果是private继承，那么父类中的public成员和protected成员就变成了子类中的private成员，父类中的private成员成了子类中比private还可怜的那种成员。
6、如果是protected继承，那么父类中的public成员和protected成员就变成了子类中的protected成员，父类中的private成员成了子类中比private还可怜的那种成员。
进一步总结：
1、父类的private成员，在三种继承下都会被变成在子类中是比private还可怜的这种成员
2、父类的public成员，在public继承下到子类中还是public，在protected继承下到子类中是protected的，在private继承下到子类中是private的。
3、父类的protected成员，在public继承下到子类中是protected的，在protected继承下到子类中是protected的，在private继承下到子类中是private的。
4、private：如果是父类中的private权限成员，那么在继承时会被降到比private还惨的这种；而如果是private继承，则不会导致父类中public和protected的成员降权到比private还惨的这种，只会降级到private权限。
5、在继承中父类中所有的成员（不管哪种权限）都会被继承给子类，而不会丢失任何一个。

2.3.6_7.继承体系下子类和父类的关系1_2
2.3.6.1、本质上是2个独立的类
(1)继承只是通过父类来快速构建子类的一种语法技术，继承后得到的子类和父类是独立的2个类
(2)程序中子类的对象和父类的对象是2个独立的对象，没有任何关系，只是形成对象的模板有部分相同
(3)子类对象中访问的子类从父类继承而来的成员，其实是属于子类自己的，并不是父类（对象）里面的
2.3.6.2、站在子类角度看继承
(1)非继承体系下的类，完全是自己“手工”构建的，所有成员根据访问权限不同而分为1个层级3大块
(2)继承体系下的子类，部分直接从父类继承，部分自己手工打造，所有成员分成2个层级（继承来的，自己写的），每个层级3大块（访问权限）
(3)继承就是子类在构建自己的过程中使用的一种快速批量成员获取方法而已
2.3.6.3、为什么父类private成员在子类中还有
(1)思考：父类的所有成员在子类中都必须有吗？有没有可能父类有一个成员其实子类没必要具备的？
(2)思考：如何做到在继承时让程序员指定父类的哪些成员参与继承，哪些不参与？
(3)选择：继承就是父类所有成员全部按分类规则传给子类
2.3.6.4、为什么父类private成员在子类中还有但不能直接访问
(1)思考：这个规定是天然的，还是人为规定的？其实是：人为规定的。  因为：访问权限这一套本身就是人为的
(2)为什么这样设计1：如果能直接访问，那就打破了父类private的含义，破坏了class的封装性
(3)为什么这样设计2：父类的private成员在子类中很大可能本来就不需要去访问，所以能直接访问反而有风险，没必要
(4)为什么这样设计3：间接访问合乎一个原则：在哪里定义的成员变量在哪里操作。子类和父类不是一个人写的时尤其要这样，避免问题
(5)这也是一个如何选择的设计哲学问题。

2.3.8.派生类和基类的构造析构关系1
2.3.8.1、派生类并不继承基类的构造和析构函数，只继承成员变量和普通成员方法
(1)不继承，意思是派生类中确实没有，不包含基类的构造和析构函数
(2)派生类自己有自己的构造和析构，规则和之前讲过的完全一样
(3)研究构造和析构函数时，一定要注意默认规则
2.2.8.2、派生类的构造函数一定会调用基类的构造函数，析构也一样
(1)代码验证：在基类和派生类中都显示提供“默认构造”并添加打印信息，通过执行结果来验证
通过代码执行结果看到的现象总结：派生类的构造函数执行之前，会先调用积累的构造函数，然后再调用自己的构造函数。而在派生类的析构函数之后，会先执行自己的析构函数，再执行基类的析构函数。
(2)代码验证：派生类的任意构造函数，可以显式指定调用基类的任意一个构造函数，通过参数匹配的方式（类似于函数重载）
(3)思考：为什么派生类的构造函数必须调用基类的1个构造函数，这样设计有什么合理性？

2.3.9.派生类和基类的构造析构关系2
2.3.9.1、为什么派生类的构造（析构）必须调用基类的某个构造（析构）
(1)牢记构造函数的2大作用：初始化成员，分配动态内存
(2)派生类和基类各自有各自的构造函数和析构函数，所以是各自管理各自的成员初始化，各自分配和释放各自所需的动态内存
(3)继承的语言特性，允许派生类调用基类的构造和析构函数，以管理派生类从基类继承而来的那些成员。
(4)明确：派生类的构造和析构处理的永远是派生类自己的对象，只是派生类对象模板中有一部分是从基类继承而来的而已。
2.3.9.2、其他几个细节
(1)派生类构造函数可以直接全部写在派生类声明的class中，也可以只在clas中声明时只写派生类构造函数名和自己的参数列表，不写继承基类的构造函数名和参数列表，而在派生类的cpp文件中再写满整个继承列表，这就是语法要求
(2)派生类析构函数则不用显式调用，直接写即可直接调用基类析构函数。猜测是因为参数列表问题。
(3)构造函数的调用顺序是先基类再派生类，而析构函数是先派生类再基类，遵循栈规则。
(4)派生类的构造函数可以在调用基类构造函数同时，用逗号间隔同时调用初始化式来初始化派生类自己的成员
2.3.9.3、派生类做的三件事
(1)吸收基类成员：除过构造和析构函数以外的所有成员全部吸收进入派生类中
(2)更改继承的成员。1是更改访问控制权限(根据继承类型还有成员在基类中的访问类型决定) 2是同名覆盖(派生类中同名成员覆盖掉基类中)
(3)添加派生类独有的成员。

2.3.10.派生类和基类的同名成员问题
2.3.10.1、派生类中再实现一个基类中的方法会怎样
(1)代码实验：派生类和基类中各自实现一个内容不同但函数原型完全相同的方法，会怎么样
(2)结论：基类对象调用的是基类的方法，派生类对象调用执行的是派生类中重新提供的方法
(3)这种派生类中同名同参方法替代掉基类方法的现象，叫做：重定义（redefining），也有人叫做隐藏。
(4)隐藏特性生效时派生类中实际同时存在2份同名同参（但在不同类域名中）的方法，同时都存在，只是一个隐藏了另一个
2.3.10.2、派生类中如何访问被隐藏的基类方法
(1)派生类对象直接调用时，隐藏规则生效，直接调用的肯定是派生类中重新实现的那一个
(2)将派生类强制类型转换成基类的类型，再去调用则这时编译器认为是基类在调用，则调用的是基类那一个，隐藏规则被绕过了
(3)在派生类内部，使用父类::方法()的方式，可以强制绕过隐藏规则，调用父类实现的那一个
2.3.10.3、注意和总结
(1)其实不止成员方法，成员变量也遵循隐藏规则。
(2)隐藏规则本质上是大小作用域内同名变量的认领规则问题，实际上2个同名成员都存在当前派生类的对象内存中的
(3)隐藏（重定义，redefining），与重载（overload）、重写（override，又叫覆盖），这三个概念一定要区分清楚。

2.3.11.子类和父类的类型兼容规则
2.3.11.1、何为类型兼容规则
(1)C和C++都是强类型语言，任何变量和对象，指针，引用等都有类型，编译器根据类型来确定很多事
(2)派生类是基类的超集，基类有的派生类都有，派生类有的基类不一定有，所以这2个类型间有关联
(3)派生类对象可以cast后当作基类对象，而基类对象不能放大成派生类对象，否则就可能会出错
(4)考虑到指针和引用与对象指向后，派生类和基类对象的访问规则就是所谓类型兼容规则。
2.3.11.2、类型兼容规则的常见情况及演示
(1)子类对象可以当作父类对象使用，也就是说子类对象可以无条件隐式类型转换为一个父类对象
(2)子类对象可以直接初始化或直接赋值给父类对象
(3)父类指针可以直接指向子类对象
(4)父类引用可以直接引用子类对象
2.3.11.3、总结
(1)派生类对象可以作为基类的对象使用，但是只能使用从基类继承的成员。
(2)类型兼容规则是多态性的重要基础之一。
(3)总结：子类就是特殊的父类 (base *p = &child;)

2.3.12.继承的优势与不良继承
2.3.12.1、为什么会有继承
(1)本质上为了代码复用
(2)继承方式很适合用来构建复杂框架体系
(3)用继承来设计类进而构建各层级对象，符合现实中的需要。举例：描述人的种群
2.3.12.2、何为不良继承
(1)鸵鸟不是鸟问题。因为鸵鸟从鸟继承了fly方法但是鸵鸟不会飞
(2)圆不是椭圆问题。因为圆从椭圆继承了长短轴属性然而圆没有长短轴属性
(3)不良继承是天然的，是现实世界和编程的继承特性之间的不完美契合
2.3.12.3、如何解决不良继承
(1)修改继承关系设计。既然圆继承椭圆是一种不良类设计就应该杜绝。去掉继承关系，两个类可以继承自同一个共同的父类，不过该类不能执行不对称的setSize计算，然后在圆和椭圆这2个子类中分别再设计以区分
(2)所有不良继承都可以归结为“圆不是椭圆”这一著名具有代表性的问题上。在不良继承中，基类总会有一些额外能力，而派生类却无法满足它。这些额外的能力通常表现为一个或多个成员函数提供的功能。要解决这一问题，要么使基类弱化，要么消除继承关系，需要根据具体情形来选择。

2.3.13.组合介绍以及与继承对比
2.3.13.1、什么是组合
(1)composition，组合，就是在一个class内使用其他多个class的对象作为成员
(2)用class tree做案例讲解
(3)组合也是一种代码复用方法，本质也是结构体包含
2.3.13.2、继承与组合的特点对比
(1)继承是a kind of（is a）关系，具有传递性,不具有对称性。
(2)组合是a part of（has a）的关系，
(3)继承是白盒复用。因为类继承允许我们根据自己的实现来覆盖重写父类的实现细节，父类的实现对于子类是可见的。
(4)继承的白盒复用特点，一定程度上破坏了类的封装特性，因为这会将父类的实现细节暴露给子类
(5)组合属于黑盒复用。被包含对象的内部细节对外是不可见的，所以它的封装性相对较好，实现上相互依赖比较小
(6)组合中被包含类会随着包含类创建而创建，消亡而消亡。组合属于黑盒复用，并且可以通过获取其它具有相同类型的对象引用或指针，在运行期间动态的定义组合。而缺点就是致使系统中的对象过多。
(7)OO设计原则是优先组合，而后继承

2.3.14_15.多继承及其二义性问题1_2
2.3.14.1、多继承
(1)多继承就是一个子类有多个父类
(2)多继承演示
(3)多继承和单继承的原理，效果并无明显区别
(4)多继承会导致二义性问题
2.3.14.2、多继承的二义性问题1
(1)场景：C多继承自A和B，则C中调用A和B的同名成员时会有二义性
(2)原因：C从A和B各自继承了一个同名（不同namespace域）成员，所以用C的对象来调用时编译器无法确定我们想调用的是哪一个
(3)解决办法1：避免出现，让A和B的public成员命名不要重复冲突。但这个有时不可控。
(4)解决办法2：编码时明确指定要调用哪一个，用c.A::func()明确指定调用的是class A的func而不是class B的
(5)解决办法3：在C中重定义func，则调用时会调用C中的func，A和B中的都被隐藏了
(6)总结：能解决，但是都没有很好的解决。
2.3.14.3、多继承的二义性问题2
(1)场景：菱形继承问题。即A为祖类，B1:A, B2:A, C:B1,B2，此时用C的对象调用A中的某个方法时会有二义性
(2)分析：c.func()有二义性，c.A::func()也有二义性，但是c.B1::func()和c.B2::func()却没有二义性
(3)解决办法：和问题1中的一样，但是问题2更隐蔽，也更难以避免
2.3.14.3、总结
(1)二义性就是歧义，好的情况表现为编译错误，不好的情况表现为运行时错误，最惨的情况表现为运行时莫名其妙
(2)随着系统的变大和变复杂，难免出现二义性，这不是程序员用不用心的问题，是系统自身带来的
(3)解决二义性问题不能靠程序员个人的细心和调试能力，而要靠机制，也就是编程语言的更高级语法特性
(4)虚函数、虚继承、纯虚函数、抽象类、override（重写，覆盖）、多态等概念就是干这些事的
(5)感慨：欲戴王冠必承其重，要揽瓷器活就得有金刚钻，C++学得越清楚就越能想象将来用C++去解决的都是些什么层次的问题

2.3.16.虚继承解决菱形继承的二义性问题
2.3.16.1、虚继承怎么用
(1)场景：菱形继承导致二义性问题，本质上是在孙子类C中有B1和B2中包含的2份A对象，所以有了二义性。
(2)虚继承解决方案：让B1和B2虚继承A，C再正常多继承B1和B2即可
(3)虚继承就这么简单，就是为了解决菱形继承的二义性问题而生，和虚函数（为了实现多态特性）并没有直接关系
2.3.16.2、虚继承的实现原理
(1)虚继承的原理是：虚基类表指针vbptr和虚基类表virtual table
(2)参考：https://blog.csdn.net/xiejingfa/article/details/48028491

2.3.17.多态和虚函数1
2.3.17.1、通过案例学多态
(1)案例：父类Animal，2个子类Dog和Cat，实现speak方法
(2)用父类指针指向各对象，调用各方法看效果，记下来
(3)将父类speak方法声明为virtual，再用父类指针调用各方法看效果，记下来
(4)对比差异，理解什么叫多态

2.3.18.多态和虚函数2
2.3.18.1、什么是多态
(1)polymorphism，多态，面向对象的三大特征之一。
(2)从宏观讲，多态就是要实现一套逻辑多种具体适配的执行结果。猫就应该是猫的叫声，狗就应该是狗的叫声。
(3)从微观讲，多态就是要一套代码在运行时根据实际对象的不同来动态绑定/跳转执行相匹配的具体函数
(4)函数声明前加virtual的即是虚函数
(5)虚函数是C++实现多态特性的基础，从语法上讲多态特性的基类方法必须是虚函数
2.3.18.2、多态中的override
(1)基类中方法声明为virtual，派生类中重新实现同名方法以实现多态，这就叫override（中文为覆盖，或重写）
(2)注意区分override和redefining，微观上最大区别就是是否有virtual，宏观上最大区别就是是否表现为多态
2.3.18.3、多态一定要通过面向对象和override来实现吗
(1)宏观上的多态是一种编程效果，微观上的多态是一种C++支持的编程技术，微观是为了去实现宏观
(2)不用C++的virtual和override，也可以实现宏观上的多态，C中我们就经常这么干。
(3)C中实现多态的案例：
(4)C++源生支持多态，实现起来更容易，后续修改和维护更容易，架构复杂后优势更大。
2.3.18.4、对比下三个概念
(1)overload，重载				同一个类里面的多个方法，函数名相同但参数列表不同
(2)redifining，重定义，隐藏		继承中子类再次实现父类中同名方法然后把父类方法隐藏掉
(3)override，覆盖，重写			继承中子类去实现父类中同名virtual方法然后实现多态特性

2.3.19_20.纯虚函数与抽象类1_2
2.3.19.1、纯虚函数
(1)纯虚函数就是基类中只有原型没有实体的一种虚函数
(2)纯虚函数形式：virtual 函数原型=0；
(3)代码实践：在基类Animal中使用纯虚函数
(4)纯虚函数为什么没有实体？因为语义上不需要
(5)纯虚函数是否占用内存？不会，因为纯虚函数所在的类根本无法实例化对象
2.3.19.2、抽象类(abstract type)
(1)带有纯虚函数的类成为抽象类。抽象类只能作为基类来派生新类，不可实例化对象。
(2)派生类必须实现基类的纯虚函数后才能用于实例化对象。
(3)抽象类的作用：将有关的数据和行为组织在一个继承层次结构中，保证派生类具有要求的行为。对应暂时无法实现的函数，可以声明为纯虚函数，留给派生类去实现。这种机制可以让语法和语义保持一致。
(4)抽象类的子类必须实现基类中的纯虚函数，这样子类才能创建对象，否则子类就还是个抽象类
2.3.19.3、接口（interface）
(1)接口是一种特殊的类，用来定义一套访问接口，也就是定义一套规约
(2)接口类中不应该定义任何成员变量 
(3)接口类中所有成员函数都是公有且都是纯虚函数
(4)有些高级语言中直接提供关键字interface定义接口，接口其实就是个纯粹的抽象基类

2.3.21.虚析构函数
2.3.21.1、什么是虚析构函数
(1)析构函数前加virtual，则析构函数变为虚析构函数
(2)规则：基类有1个或多个虚函数时（注意不要求是纯虚函数），则其析构函数应该声明为virtual
2.3.21.2、为什么需要虚析构函数
(1)代码演示：父子类各自添加析构函数，用2种分配和回收对象的方式分别实验，观察析构函数被调用的规律
(2)结论：虚析构函数在各种情况下总能调用正确的（和对象真正匹配的）析构函数。
2.3.21.3、分析和总结
(1)其实虚函数的virtual的价值，就是让成员函数在运行时动态解析和绑定具体执行的函数，这是RTTI机制的一部分。
(2)析构函数也是成员函数，加virtual的效果和普通成员函数加virtual没什么本质差异
(3)加virtual是有开销的，运行时动态绑定不如编译时静态绑定效率高资源消耗优，但是可以多态。

2.3.22.using重新定义继承时访问权限
2.3.22.1、using关键字在非public继承时的权限重开作用
(1)父类的public方法在private/protected继承时，到了子类就成了private/protected而不是public了，无法用子类对象来调用了
(2)解决方法1是改为public继承，有用但是有时候不得不protected或者private继承时就没办法了
(3)解决方法2是在子类中再实现一个public的方法，内部调用父类继承而来的那个方法，能用但是有点麻烦而且有额外开销
(3)解决犯法3是在子类中使用using关键字将该方法声明为public访问权限，本质上类似于权限打洞
(4)用法：在子类public声明中使用 using Base::func; 即可，不带返回值类型不带参数列表。
(5)注意：using只用于private/protected继承中的权限损失找回，如果方法在父类中本来就是private的子类中没法using后访问
2.3.22.2、本部分课程总结
(1)本部分主要讲了OO的2个特性：继承和多态，其中继承和权限管控、继承中的构造和析构、隐藏和覆盖、虚函数和多态、纯虚函数和抽象类、接口、静态和动态绑定等是本课程的重点。
(2)面向对象三大特征中：封装是基础、继承是关键、多态是延伸。
(3)本部分内容很重要，属于C++知识体系中关键基础零件，对于以后理解复杂代码和架构意义重大，必须彻底理解和熟悉。
(4)要求要见过、认识、会写、理解原理、熟练运用。























